# 玩崩玩的 题解

## 思路

串串题。用 SAM 大概也是能做的，但这里就说一下 SA 怎么做就好。  

我们看这个题会想起什么题呢？那就是传世经典“优秀的拆分”，而那道题其实就是本题中 $m=0$ 的部分分。如果你是努力型选手，在本题中可以额外获得 $10$ 分，这无疑是良心出题人的馈赠。  

仿照 $m=0$ 的部分，我们得到了一个这样的算法：
- 首先，我们枚举 $A$ 串的长度 $\rm{len}$。按照 $\rm{len}$，我们将原序列分成若干个小块，我们标记块的端点为“关键点”。
- 我们枚举每个关键点 $l$，那么，他在后面的对应点应该是 $r=l+len+m$。这样的点对我们称之为关键点对，只有这个点对向两侧伸展的子串才能使正确答案。
- 因此，我们枚举这样的关键点对。按照优秀的拆分的思想，我们求这两个点对向前延伸和向后延伸的最长公共子串，也就是说，求 $s[1, l]$ 和 $s[1, r]$ 的 LCS，与 $s[l, n]$ 和 $s[r, n]$ 的 LCP。求完以后，我们很容易看出产生的贡献似乎为 $\rm{LCP}+\rm{LCS}-\rm{len}-1$ 状物。
- 具体的，若 LCS，LCP 均不为零，贡献即为 $\rm{LCP}+\rm{LCS}-\rm{len}-1$。若有一个为 $0$，则为 $\rm{LCP}+\rm{LCS}-\rm{len}$。若两者不交，则无贡献。
- 实现上，求 LCS 和 LCP 个人喜欢正反两遍 SA 求出来。

时间复杂度为 $O(n\log n)$。
